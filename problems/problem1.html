<!DOCTYPE html>
<html lang="en">
<head>
    <title>CPSC 487/587</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/10.3.0/math.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/quaternion@1.5.1/quaternion.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/numeric@1.2.6/numeric-1.2.6.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stats.js@0.17.0/build/stats.min.js"></script>
    <script type="importmap">
        {
            "imports": {
              "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
              "three/": "https://unpkg.com/three@0.160.0/"
            }
        }
    </script>
</head>
<body>
<script type="module">
    import {get_default_lil_gui, refresh_displays} from "../js/utils/utils_three.js";
    import {ThreeEngine} from "../js/utils/utils_three.js";
    import {B1Z1Robot, XArm7Robot} from "../js/utils/utils_robot.js";
    import { add_matrix_matrix,
            frobenius_norm_matrix,
            identity_matrix, matrix_inverse_3x3,
            mul_matrix_matrix, normalized_matrix,
            mul_matrix_scalar, sub_matrix_matrix, transpose, unroll_matrix_to_list} from "../js/utils/utils_math.js";

    // todo: create a visualization that demonstrates your knowledge of forward kinematics on a robot model.
    // todo: The "default" assignment is to recreate this visualization:
    // todo: https://yale-cpsc-487-587-internal-djrakita-c95fa6c3239a481a48d29a6b0fd.gitlab.io/html/unit4_visualizations/fk.html
    // todo: or this visualization:
    // todo: https://yale-cpsc-487-587-internal-djrakita-c95fa6c3239a481a48d29a6b0fd.gitlab.io/html/unit4_visualizations/fk2.html
    // todo: however, feel free to deviate from this if you want to.
    // todo: I will be adding information to the class wiki on important properties and subroutines regarding the robot
    // todo: object created for this class.  If you have questions, refer to that wiki or ask me over slack.

    let engine = ThreeEngine.new_default_3d();
    let robot = new XArm7Robot();

    let settings = {
        displayMesh: true,
        displayWireframe: false,
  
        dof0: 0,
        dof1: 0,
        dof2: 0,
        dof3: 0,
        dof4: 0,
        dof5: 0,
        dof6: 0,
        dof7: 0,

        link0: false,
        link1: false,
        link2: false,
        link3: false,
        link4: false,
        link5: false,
        link6: false,
        link7: false,
        link8: false,
        link9: false,
        link10: false,
        link11: false,
        link12: false,
        link13: false,
        link14: false,
        link15: false,
        link16: false,
        link17: false,
        link18: false,
        link19: false
    }

    let actions = {
        reset: () => {
            settings.dof0 = 0;
            settings.dof1 = 0;
            settings.dof2 = 0;
            settings.dof3 = 0;
            settings.dof4 = 0;
            settings.dof5 = 0;
            settings.dof6 = 0;
            settings.dof7 = 0;
            refresh_displays(gui);
        },
        select_all_frames: () => {
            for (let i = 0; i < robot.links.length; i++) {
                settings["link" + i.toString()] = true;
              }
            refresh_displays(gui);
        },
        deselect_all_frames: () => {
            for (let i = 0; i < robot.links.length; i++) {
                settings["link" + i.toString()] = false;
              }
            refresh_displays(gui);
        }
    }

    let gui = get_default_lil_gui();

    let folder1 = gui.addFolder('Controls');
    folder1.add(settings, 'displayMesh').name("Display Mesh");
    folder1.add(settings, 'displayWireframe').name("Display Wireframe");
    //folder1.add(settings, 'displayMeshWithFrame').name("Display Mesh Only with Frame");

    let counter = 0;
    let dofFolder = gui.addFolder('DOFs');

    for (let i = 0; i < robot.joints.length; i++) {
        let joint = robot.joints[i];
        if (joint.joint_num_dofs != 0) {
          if (joint.joint_type_string === 'floating') {
            for (let j = 0; j < 3; j++) {
                settings["dof" + counter.toString()] = 0;
                dofFolder.add(this.settings, 'dof' + counter.toString(), -1, 1);
                counter++;
              }

            for (let j = 0; j < 3; j++) {
              settings["dof" + counter.toString()] = 0;
              dofFolder.add(this.settings, "dof" + counter.toString(), -Math.PI, Math.PI);
              counter++;
            }

          } else {
            let lowerBound = joint.lower_bound;
            let upperBound = joint.upper_bound;
            settings["dof" + counter.toString()] = Math.max(0, lowerBound);
            dofFolder.add(settings, "dof" + counter.toString(), lowerBound, upperBound);
            counter++;
          }
        }
      }

    let folder3 = gui.addFolder('Actions');
    folder3.add(actions, 'reset').name("Reset");
    folder3.add(actions, 'select_all_frames').name("Select All Frames");
    folder3.add(actions, 'deselect_all_frames').name("Deselect All Frames");

    let folder4 = gui.addFolder('Links');
    for (let i = 0; i < robot.links.length; i++) {
        folder4.add(settings, "link" + i.toString()).name("link " + i.toString() + ": " + robot.links[i].link_name);
      }

    // this will spawn all of the robot's links at the origin
    robot.spawn_robot(engine);
    robot.set_wireframe_visibility(engine, settings.displayWireframe);
    robot.set_mesh_visibility(engine, settings.displayMesh);

    function exp_so3_to_SO3(so3_mat) {
        let I = identity_matrix(3);
        let A2 = mul_matrix_matrix(so3_mat, so3_mat);
    
        let ai = so3_mat[2][1];
        let bi = so3_mat[0][2];
        let ci = so3_mat[1][0];
    
        let u = [[ai], [bi], [ci]];
        let beta = frobenius_norm_matrix(u);
    
        let p;
        let q;
    
        if (beta < 0.001) {
            p = 1 - (Math.pow(beta, 2) / 6.0) + (Math.pow(beta, 4) / 120.0);
            q = 0.5 - (Math.pow(beta, 2) / 24.0) + (Math.pow(beta, 4) / 720.0);
        } else {
            p = Math.sin(beta) / beta;
            q = (1 - Math.cos(beta)) / Math.pow(beta, 2);
        }
    
        return add_matrix_matrix(add_matrix_matrix(I, mul_matrix_scalar(so3_mat, p)), mul_matrix_scalar(A2, q));
    }

    function exp_se3_to_SE3(se3_mat) {
        let SO3 = [
            [se3_mat[0][0], se3_mat[0][1], se3_mat[0][2]],
            [se3_mat[1][0], se3_mat[1][1], se3_mat[1][2]],
            [se3_mat[2][0], se3_mat[2][1], se3_mat[2][2]]
        ];
        let t = [se3_mat[0][3], se3_mat[1][3], se3_mat[2][3]];
    
        let A2 = mul_matrix_matrix(SO3, SO3);
        let I = identity_matrix(3);
        let beta = frobenius_norm_matrix([SO3[2][1], SO3[0][2], SO3[1][0]]);  
    
        let p, q;
        if (beta < 0.001) {
            p = 1 - (beta * beta / 6) + (beta * beta * beta * beta / 120);
            q = 0.5 - (beta * beta / 24) + (beta * beta * beta * beta / 720);
        } else {
            p = Math.sin(beta) / beta;
            q = (1 - Math.cos(beta)) / (beta * beta);
        }
    
        let SO3_mat = add_matrix_matrix(add_matrix_matrix(I, mul_matrix_scalar(SO3, p)), mul_matrix_scalar(SO3, q));
    
        let C = identity_matrix(3);
        C = add_matrix_matrix(C, mul_matrix_scalar(SO3, p));
        C = add_matrix_matrix(C, mul_matrix_scalar(mul_matrix_matrix(SO3, SO3), q));
        let t_transformed = mul_matrix_matrix(C, [[t[0]], [t[1]], [t[2]]]);
        return [
            [SO3_mat[0][0], SO3_mat[0][1], SO3_mat[0][2], t_transformed[0][0]],
            [SO3_mat[1][0], SO3_mat[1][1], SO3_mat[1][2], t_transformed[1][0]],
            [SO3_mat[2][0], SO3_mat[2][1], SO3_mat[2][2], t_transformed[2][0]],
            [0, 0, 0, 1]
        ];
    }    

    function forward_kinematics_SE3(robot, jointValues) {
        //console.log("Calculating forward kinematics...");
        let numLinks = robot.num_links();
        let linkTransforms = [];
        let R_zero_4_4 = [[ 0, 0, 0, 0 ],
                          [ 0, 0, 0, 0 ],
                          [ 0, 0, 0, 0 ],
                          [0,0,0,1]];

        for (let i = 0; i < numLinks; i++) {
          linkTransforms.push(exp_se3_to_SE3(R_zero_4_4));
        }
      
        let kinematicHierarchy = robot.kinematic_hierarchy;

        for (let i = 1; i < kinematicHierarchy.length; i++) {
            let childLinks = kinematicHierarchy[i];
            childLinks.forEach(linkIdx => {
                const link = robot.links[linkIdx];
                const parentJointIdx = link.parent_joint_idx;
                const parentLinkIdx = link.parent_link_idx;
                const joint = robot.joints[parentJointIdx];
                const jointType = joint.joint_type_string;
                const parentTransform = linkTransforms[parentLinkIdx];
                const jointTransform = joint.xyz_rpy_SE3_matrix;
                let resultTransform = mul_matrix_matrix(parentTransform, jointTransform);
                //console.log(`Link ${linkIdx}: parent ${parentLinkIdx}, joint ${parentJointIdx}, type ${jointType}`);
        
                if (jointType === "prismatic") {
                    let translationAmount = jointValues[joint.dof_idx];
                    let translationMatrix = [[1, 0, 0, translationAmount * joint.axis[0][0]],
                                            [0, 1, 0, translationAmount * joint.axis[1][0]],
                                            [0, 0, 1, translationAmount * joint.axis[2][0]],
                                            [0, 0, 0, 1]];
                    resultTransform = mul_matrix_matrix(resultTransform, translationMatrix);

                } else if (jointType === "revolute") {
                    let rotationAmount = jointValues[joint.dof_idx];
                    let axisNormalized = normalized_matrix(joint.axis);
                    let scaledAxis = mul_matrix_scalar(axisNormalized, rotationAmount);
                    let rotationVector = unroll_matrix_to_list(scaledAxis);
                    let se3Matrix = [[ 0, -rotationVector[2], rotationVector[1], 0 ],
                                    [ rotationVector[2], 0, -rotationVector[0], 0 ],
                                    [ -rotationVector[1], rotationVector[0], 0, 0 ],
                                    [0,0,0,1]];
                    let rotationMatrix = exp_se3_to_SE3(se3Matrix);
                    resultTransform = mul_matrix_matrix(resultTransform, rotationMatrix);

                } else if (jointType === "floating") {
                    let rotationIndices = joint.rotationDofIndices;
                    let translationIndices = joint.translationDofIndices;
                    let rotationValues = [jointValues[rotationIndices[0]],
                                        jointValues[rotationIndices[1]],
                                        jointValues[rotationIndices[2]]];

                    let translationValues = [jointValues[translationIndices[0]],
                                            jointValues[translationIndices[1]],
                                            jointValues[translationIndices[2]]];

                    let rotationMatrixSO3 = vec3_to_so3_mat(rotationValues);
                    let fullRotationMatrix = exp_so3_to_SO3(rotationMatrixSO3);
                    let combinedTransformation = [[fullRotationMatrix[0][0], fullRotationMatrix[0][1], fullRotationMatrix[0][2], translationValues[0]],
                                                [fullRotationMatrix[1][0], fullRotationMatrix[1][1], fullRotationMatrix[1][2], translationValues[1]],
                                                [fullRotationMatrix[2][0], fullRotationMatrix[2][1], fullRotationMatrix[2][2], translationValues[2]],
                                                [0, 0, 0, 1]];
                    resultTransform = mul_matrix_matrix(resultTransform, combinedTransformation);
                }
                
                linkTransforms[linkIdx] = resultTransform;
          });
        }
        //console.log("Final link transforms:", linkTransforms);
        return linkTransforms;
      }

    function setRobotState(engine, robot, jointValues) {
        //console.log("Setting robot state with joint values:", jointValues);
        const transforms = forward_kinematics_SE3(robot, jointValues);
        for (let i = 0; i < transforms.length; i++) {
            robot.set_link_mesh_pose_from_SE3_matrix(engine, i, transforms[i]);
          }
        //console.log("Computed link transforms:", robotState);
    }

    engine.animation_loop( ()  => {
        let jointValues = [];
        for (let i = 0; i < robot.num_dofs(); i++){
            let dof_value = settings["dof" + i.toString()];
            jointValues.push(dof_value);
        }

        //console.log("Joint values at animation loop:", jointValues);
        robot.set_wireframe_visibility(engine, settings.displayWireframe);
        robot.set_mesh_visibility(engine, settings.displayMesh);
        setRobotState(engine, robot, jointValues);
    });

</script>
</body>
</html>